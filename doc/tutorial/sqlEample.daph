
// ****************************************************************************
// Reading the base data
// ****************************************************************************

c = readFrame($inCustomer);
o = readFrame($inOrders);


// ****************************************************************************
// Query set up and Execution
// ****************************************************************************

// Register the Frames for the SQL Parser
// The String is the Name of the Frame that the Parser will use.

registerView(c, "customer");
registerView(o, "orders");

// Query Exec
// The Query needs to be fully quanitzised to work. This applies for the Projection and the GROUP BY Claus
// DAPHNE doesn't support automatic casting at the moment so you need to make sure the base datatypes match.
res = sql("SELECT c.a, c.b, c.c, SUM(orders.O_TOTALPRICE)
			FROM customer c
			JOIN orders o ON c.C_CUSTKEY = o.O_CUSTKEY
			WHERE c.C_MKTSEGMENT <= $mktSegmentUpper
			AND o.O_ORDERDATE >= $orderDateLower
			GROUP BY c.CUSTKEY");


//After the SQL Operation we can use the result todo a simple regression on it.

// ****************************************************************************
// ML part
// ****************************************************************************

// TODO Do this after the column extraction.
XY = as.matrix.f64(res);

tp3 = now();

// TODO Do this on the frame, then it's zero cost.
X0 = XY[, seq(1, as.si64(ncol(XY)) - 2, 1)];

// TODO Most of the remaining ops (until the matmul) could be done (more)
// efficiently on frames, no need to switch to matrices so early. But this also
// applies to the baseline of Pandas+TF, even in MonetDB (although, then the
// user would have to think about it manually).

i0 = fill(-1, 1, 2); // don't encode C_NAME, C_ADDRESS
i1 = fill(25, 1, 1); // encode C_NATIONKEY
i2 = fill(-1, 1, 2); // don't encode C_PHONE, C_ACCTBAL
i3 = fill(5, 1, 1); // encode C_MKTSEGMENT
i4 = fill(-1, 1, 1); // don't encode C_COMMENT
i = cbind(cbind(cbind(i0, i1), cbind(i2, i3)), i4);

X = oneHot(X0, i);

// TODO Do this on the frame, then it's zero cost.
// TODO Ensure this is a no-op for one column of the correct value type.
y = XY[, seq(as.si64(ncol(XY)) - 1, as.si64(ncol(XY)) - 1, 1)];

X = (X - mean(X, 1)) / stddev(X, 1);

X = cbind(X, fill(1.0, nrow(X), 1));

lambda = fill(0.001, ncol(X), 1);
A = t(X) @ X;
b = t(X) @ y;

// TODO: Does that still make sense, algorithmically?
A = replace(A, nan, 0.0);
b = replace(b, nan, 0.0);

A = A + diagMatrix(lambda);

beta = solve(A, b);

// ****************************************************************************
// Result output
// ****************************************************************************

print(beta);
