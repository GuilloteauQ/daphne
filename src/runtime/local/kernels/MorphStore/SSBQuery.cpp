/**********************************************************************************************
 * Copyright (C) 2019 by MorphStore-Team                                                      *
 *                                                                                            *
 * This file is part of MorphStore - a compression aware vectorized column store.             *
 *                                                                                            *
 * This program is free software: you can redistribute it and/or modify it under the          *
 * terms of the GNU General Public License as published by the Free Software Foundation,      *
 * either version 3 of the License, or (at your option) any later version.                    *
 *                                                                                            *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;  *
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *
 * See the GNU General Public License for more details.                                       *
 *                                                                                            *
 * You should have received a copy of the GNU General Public License along with this program. *
 * If not, see <http://www.gnu.org/licenses/>.                                                *
 **********************************************************************************************/

/**
 * @brief This file was automatically generated by mal2morphstore.py.
 */

#include "core/memory/mm_glob.h"
#include "core/morphing/format.h"
#include "core/persistence/binary_io.h"
#include "core/storage/column.h"
#include "core/utils/basic_types.h"
#include "core/utils/printing.h"

#include "vector/vector_extension_structs.h"
#include "vector/vector_primitives.h"

#include "core/morphing/format.h"
#include "core/morphing/uncompr.h"
#include "core/operators/otfly_derecompr/join_uncompr.h"
#include "core/operators/otfly_derecompr/agg_sum_all.h"
#include "core/operators/otfly_derecompr/between.h"
#include "core/operators/otfly_derecompr/calc_uncompr.h"
#include "core/operators/otfly_derecompr/intersect.h"
#include "core/operators/otfly_derecompr/project.h"
#include "core/operators/otfly_derecompr/select.h"
#include <functional>

#include <iostream>

using namespace morphstore;

/// @todo Remove before push to main.

// ****************************************************************************
// Schema (only the part required for this query)
// ****************************************************************************

struct date_t {
    const column<uncompr_f> * d_datekey;
    const column<uncompr_f> * d_year;
} date;

struct lineorder_t {
    const column<uncompr_f> * lo_discount;
    const column<uncompr_f> * lo_extendedprice;
    const column<uncompr_f> * lo_orderdate;
    const column<uncompr_f> * lo_quantity;
} lineorder;


// ****************************************************************************
// Main program
// ****************************************************************************

int main(int argc, const char ** argv) {
    if(argc != 2) {
        // TODO Whether there is a slash at the end should not matter.
        std::cerr << "This query program expects exactly one argument: the "
                     "relative or absolute path to the directory containing the "
                     "column files (without trailing slash)." << std::endl;
        return 1;
    }
    const std::string dataPath(argv[1]);

    using ps = vectorlib::scalar<vectorlib::v64<uint64_t> >;


    // ------------------------------------------------------------------------
    // Loading the base data
    // ------------------------------------------------------------------------

    std::cerr << "Loading the base data started... ";
    std::cerr.flush();

    // Load the base columns.
    date.d_datekey             = binary_io<uncompr_f>::load(dataPath + "/date.d_datekey.uncompr_f.bin");
    date.d_year                = binary_io<uncompr_f>::load(dataPath + "/date.d_year.uncompr_f.bin");
    lineorder.lo_discount      = binary_io<uncompr_f>::load(dataPath + "/lineorder.lo_discount.uncompr_f.bin");
    lineorder.lo_extendedprice = binary_io<uncompr_f>::load(dataPath + "/lineorder.lo_extendedprice.uncompr_f.bin");
    lineorder.lo_orderdate     = binary_io<uncompr_f>::load(dataPath + "/lineorder.lo_orderdate.uncompr_f.bin");
    lineorder.lo_quantity      = binary_io<uncompr_f>::load(dataPath + "/lineorder.lo_quantity.uncompr_f.bin");

    // No morphing of the base columns required.


    std::cerr << "done." << std::endl;

    // ------------------------------------------------------------------------
    // Query execution
    // ------------------------------------------------------------------------

    std::cerr << "Query execution started... ";
    std::cerr.flush();

    auto C_47 = morphstore::between<vectorlib::greaterequal, vectorlib::lessequal, ps, uncompr_f, uncompr_f>(lineorder.lo_discount, 1, 3);

    auto C_53_0 = morphstore::select<ps, vectorlib::less, uncompr_f, uncompr_f >(lineorder.lo_quantity, 25);
    auto C_53 = morphstore::intersect_sorted<ps, uncompr_f, uncompr_f, uncompr_f >(C_53_0, C_47);

    auto X_55 = morphstore::my_project_wit_t<ps, uncompr_f, uncompr_f, uncompr_f >::apply(lineorder.lo_orderdate, C_53);

    auto C_77 = morphstore::select<ps, vectorlib::equal, uncompr_f, uncompr_f >(date.d_year, 1993);

    auto X_79 = morphstore::my_project_wit_t<ps, uncompr_f, uncompr_f, uncompr_f >::apply(date.d_datekey, C_77);

    auto X_81 = semi_join<
            ps,
            uncompr_f,
            uncompr_f,
            uncompr_f
    >
            (X_79, X_55);

    auto X_89_0 = morphstore::my_project_wit_t<ps, uncompr_f, uncompr_f, uncompr_f >::apply(lineorder.lo_extendedprice, C_53);
    X_89_0->template prepare_for_random_access<ps>();
    auto X_89 = morphstore::my_project_wit_t<ps, uncompr_f, uncompr_f, uncompr_f >::apply(X_89_0, X_81);

    auto X_90_0 = morphstore::my_project_wit_t<ps, uncompr_f, uncompr_f, uncompr_f >::apply(lineorder.lo_discount, C_53);
    X_90_0->template prepare_for_random_access<ps>();
    auto X_90 = morphstore::my_project_wit_t<ps, uncompr_f, uncompr_f, uncompr_f >::apply(X_90_0, X_81);

    auto X_93 = morphstore::calc_binary<vectorlib::mul, ps, uncompr_f, uncompr_f, uncompr_f >(X_89, X_90);

    auto X_96 = morphstore::agg_sum_all<ps, uncompr_f, uncompr_f >(X_93);


    std::cerr << "done." << std::endl;

    // ------------------------------------------------------------------------
    // Result output
    // ------------------------------------------------------------------------

    std::cerr << "Result output started... ";
    std::cerr.flush();

    // No morphing of the result columns required.

    // Print the result columns.
    print_columns_csv({X_96});

    // Free all intermediate results.
#ifdef MSV_NO_SELFMANAGED_MEMORY
    delete C_47;
    delete C_53_0;
    delete C_53;
    delete X_55;
    delete C_77;
    delete X_79;
    delete X_81;
    delete X_89_0;
    delete X_89;
    delete X_90_0;
    delete X_90;
    delete X_93;
    delete X_96;
#endif

    std::cerr << "done." << std::endl;

    return 0;

    // ------------------------------------------------------------------------
    // Automatic analysis of the translated program
    // ------------------------------------------------------------------------

    //         Intermediates used before assigned
    // [good]: Found none.
    //
    //         Intermediates never used
    // [good]: Found none.
}
