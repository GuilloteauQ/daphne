/**********************************************************************************************
 * Copyright (C) 2019 by MorphStore-Team                                                      *
 *                                                                                            *
 * This file is part of MorphStore - a compression aware vectorized column store.             *
 *                                                                                            *
 * This program is free software: you can redistribute it and/or modify it under the          *
 * terms of the GNU General Public License as published by the Free Software Foundation,      *
 * either version 3 of the License, or (at your option) any later version.                    *
 *                                                                                            *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;  *
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *
 * See the GNU General Public License for more details.                                       *
 *                                                                                            *
 * You should have received a copy of the GNU General Public License along with this program. *
 * If not, see <http://www.gnu.org/licenses/>.                                                *
 **********************************************************************************************/

/**
 * @brief This file was automatically generated by mal2morphstore.py.
 */

#include "core/memory/mm_glob.h"
#include "core/morphing/format.h"
#include "core/persistence/binary_io.h"
#include "core/storage/column.h"
#include "core/utils/basic_types.h"
#include <runtime/local/datastructures/Frame.h>

#include <runtime/local/kernels/EwBinaryObjSca.h>
#include <runtime/local/kernels/EwBinaryMat.h>
#include <runtime/local/kernels/FilterRow.h>
#include <runtime/local/kernels/SemiJoin.h>
#include <runtime/local/kernels/AggAll.h>
#include <runtime/local/kernels/AggOpCode.h>
#include <runtime/local/kernels/ThetaJoin.h>
#include <runtime/local/kernels/MorphStore/select.h>

#include <functional>

#include <iostream>

/// @todo Remove before push to main.

// ****************************************************************************
// Schema (only the part required for this query)
// ****************************************************************************

struct date_t {
    const morphstore::column<morphstore::uncompr_f> * d_datekey;
    const morphstore::column<morphstore::uncompr_f> * d_year;
} date;

struct lineorder_t {
    const morphstore::column<morphstore::uncompr_f> * lo_discount;
    const morphstore::column<morphstore::uncompr_f> * lo_extendedprice;
    const morphstore::column<morphstore::uncompr_f> * lo_orderdate;
    const morphstore::column<morphstore::uncompr_f> * lo_quantity;
} lineorder;


// ****************************************************************************
// Main program
// ****************************************************************************

int main(int argc, const char ** argv) {
    if(argc != 2) {
        // TODO Whether there is a slash at the end should not matter.
        std::cerr << "This query program expects exactly one argument: the "
                     "relative or absolute path to the directory containing the "
                     "column files (without trailing slash)." << std::endl;
        return 1;
    }
    const std::string dataPath(argv[1]);

    using ps = vectorlib::scalar<vectorlib::v64<uint64_t> >;


    // ------------------------------------------------------------------------
    // Loading the base data
    // ------------------------------------------------------------------------

    std::cerr << "Loading the base data started... ";
    std::cerr.flush();

    // Load the base columns.
    date.d_datekey             = morphstore::binary_io<morphstore::uncompr_f>::load(dataPath + "/date.d_datekey.uncompr_f.bin");
    date.d_year                = morphstore::binary_io<morphstore::uncompr_f>::load(dataPath + "/date.d_year.uncompr_f.bin");
    lineorder.lo_discount      = morphstore::binary_io<morphstore::uncompr_f>::load(dataPath + "/lineorder.lo_discount.uncompr_f.bin");
    lineorder.lo_extendedprice = morphstore::binary_io<morphstore::uncompr_f>::load(dataPath + "/lineorder.lo_extendedprice.uncompr_f.bin");
    lineorder.lo_orderdate     = morphstore::binary_io<morphstore::uncompr_f>::load(dataPath + "/lineorder.lo_orderdate.uncompr_f.bin");
    lineorder.lo_quantity      = morphstore::binary_io<morphstore::uncompr_f>::load(dataPath + "/lineorder.lo_quantity.uncompr_f.bin");

    // No morphing of the base columns required.

    std::string labelsDate[] = {"d_datekey", "d_year"};
    std::string labelsLineorder[] = {"lo_discount", "lo_extendedprice", "lo_orderdate", "lo_quantity"};

    std::vector<Structure *> resultColsDate = {};
    std::vector<Structure *> resultColsLineorder = {};

    auto *colDatekey = const_cast<morphstore::column<morphstore::uncompr_f> *>(date.d_datekey);
    auto *colYear = const_cast<morphstore::column<morphstore::uncompr_f> *>(date.d_year);
    auto *colDiscount = const_cast<morphstore::column<morphstore::uncompr_f> *>(lineorder.lo_discount);
    auto *colExtended = const_cast<morphstore::column<morphstore::uncompr_f> *>(lineorder.lo_extendedprice);
    auto *colOrderd = const_cast<morphstore::column<morphstore::uncompr_f> *>(lineorder.lo_orderdate);
    auto *colQuant = const_cast<morphstore::column<morphstore::uncompr_f> *>(lineorder.lo_quantity);

    /// Change the persistence type to disable the deletion and deallocation of the data.

    colDatekey->set_persistence_type(morphstore::storage_persistence_type::externalScope);
    colYear->set_persistence_type(morphstore::storage_persistence_type::externalScope);
    colDiscount->set_persistence_type(morphstore::storage_persistence_type::externalScope);
    colExtended->set_persistence_type(morphstore::storage_persistence_type::externalScope);
    colOrderd->set_persistence_type(morphstore::storage_persistence_type::externalScope);
    colQuant->set_persistence_type(morphstore::storage_persistence_type::externalScope);

    uint64_t * ptrDatekey = colDatekey->get_data();
    uint64_t * ptrYear = colYear->get_data();
    uint64_t * ptrDiscount = colDiscount->get_data();
    uint64_t * ptrExtended = colExtended->get_data();
    uint64_t * ptrOrderd = colOrderd->get_data();
    uint64_t * ptrQuant = colQuant->get_data();

    std::shared_ptr<uint64_t[]> shrdPtrDatekey(ptrDatekey);
    std::shared_ptr<uint64_t[]> shrdPtrYear(ptrYear);
    std::shared_ptr<uint64_t[]> shrdPtrDiscount(ptrDiscount);
    std::shared_ptr<uint64_t[]> shrdPtrExtended(ptrExtended);
    std::shared_ptr<uint64_t[]> shrdPtrOrderd(ptrOrderd);
    std::shared_ptr<uint64_t[]> shrdPtrQuant(ptrQuant);

    auto resultDatekey = DataObjectFactory::create<DenseMatrix<uint64_t>>(colDatekey->get_count_values(), 1, shrdPtrDatekey);
    auto resultYear = DataObjectFactory::create<DenseMatrix<uint64_t>>(colYear->get_count_values(), 1, shrdPtrYear);
    auto resultDiscount = DataObjectFactory::create<DenseMatrix<uint64_t>>(colDiscount->get_count_values(), 1, shrdPtrDiscount);
    auto resultExtended = DataObjectFactory::create<DenseMatrix<uint64_t>>(colExtended->get_count_values(), 1, shrdPtrExtended);
    auto resultOrderd = DataObjectFactory::create<DenseMatrix<uint64_t>>(colOrderd->get_count_values(), 1, shrdPtrOrderd);
    auto resultQuant = DataObjectFactory::create<DenseMatrix<uint64_t>>(colQuant->get_count_values(), 1, shrdPtrQuant);

    resultColsDate.push_back(resultDatekey);
    resultColsDate.push_back(resultYear);
    resultColsLineorder.push_back(resultDiscount);
    resultColsLineorder.push_back(resultExtended);
    resultColsLineorder.push_back(resultOrderd);
    resultColsLineorder.push_back(resultQuant);
    delete colDatekey, delete colYear, delete colDiscount, delete colExtended, delete colOrderd, delete colQuant;

    auto dateFrame = DataObjectFactory::create<Frame>(resultColsDate, labelsDate);
    auto lineorderFrame = DataObjectFactory::create<Frame>(resultColsLineorder, labelsLineorder);

    std::cerr << "done." << std::endl;

    // ------------------------------------------------------------------------
    // Query execution
    // ------------------------------------------------------------------------

    std::cerr << "Query execution started... ";
    std::cerr.flush();

    DenseMatrix<uint64_t> * X_47 = nullptr;
    DenseMatrix<uint64_t> * X_48 = nullptr;

    size_t lower = 1;
    size_t upper = 3;
    ewBinaryObjSca<DenseMatrix<uint64_t>, DenseMatrix<uint64_t>, uint64_t>(BinaryOpCode::GE, X_47, lineorderFrame->getColumn<uint64_t>("lo_discount"), lower, nullptr);
    ewBinaryObjSca<DenseMatrix<uint64_t>, DenseMatrix<uint64_t>, uint64_t>(BinaryOpCode::LE, X_48, lineorderFrame->getColumn<uint64_t>("lo_discount"), upper, nullptr);

    DenseMatrix<uint64_t> * X_49 = nullptr;
    ewBinaryMat<DenseMatrix<uint64_t>, DenseMatrix<uint64_t>, DenseMatrix<uint64_t>>(BinaryOpCode::AND, X_49, X_47, X_48, nullptr);

    DenseMatrix<uint64_t> * X_50 = nullptr;
    //ewBinaryObjSca<DenseMatrix<uint64_t>, DenseMatrix<uint64_t>, uint64_t>(BinaryOpCode::LT, X_50, lineorderFrame->getColumn<uint64_t>("lo_quantity"), 25, nullptr);
    select(X_50, lineorderFrame->getColumn<uint64_t>("lo_quantity"), CompareOperation::LessThan, 25);
    std::cout << is_aligned(X_50->getValues(), 64) << std::endl;

    DenseMatrix<uint64_t> * X_51 = nullptr;
    ewBinaryMat<DenseMatrix<uint64_t>, DenseMatrix<uint64_t>, DenseMatrix<uint64_t>>(BinaryOpCode::AND, X_51, X_50, X_49, nullptr);

    Frame * X_53 = nullptr;
    filterRow<Frame, Frame, uint64_t>(X_53, lineorderFrame, X_51, nullptr);

    DenseMatrix<uint64_t> * X_76 = nullptr;
    ewBinaryObjSca<DenseMatrix<uint64_t>, DenseMatrix<uint64_t>, uint64_t>(BinaryOpCode::EQ, X_76, dateFrame->getColumn<uint64_t>("d_year"), 1993, nullptr);

    Frame * X_77 = nullptr;
    filterRow<Frame, Frame, uint64_t>(X_77, dateFrame, X_76, nullptr);

    Frame * X_81 = nullptr;
    DenseMatrix<uint64_t> * TEMP = nullptr;
    auto lhsQLabels = new const char*[10]{"lo_orderdate"};
    auto rhsQLabels = new const char*[10]{"d_datekey"};
    uint64_t equations = 1;

    /// R.a == S.a
    auto cmps = new CompareOperation[10]{CompareOperation::Equal};

    thetaJoin(X_81, X_53, X_77, lhsQLabels, equations, rhsQLabels, equations, cmps, equations);
    //semiJoin(X_81, TEMP, X_53, X_77, "lo_orderdate", "d_datekey", nullptr);

    DenseMatrix<uint64_t> * X_93 = nullptr;
    ewBinaryMat(BinaryOpCode::MUL, X_93, X_81->getColumn<uint64_t>("lo_extendedprice"), X_81->getColumn<uint64_t>("lo_discount"), nullptr);

    unsigned long result = aggAll(AggOpCode::SUM, X_93, nullptr);

    std::cout << result << std::endl;
    std::cerr << "done." << std::endl;

    // ------------------------------------------------------------------------
    // Result output
    // ------------------------------------------------------------------------

    std::cerr << "Result output started... ";
    std::cerr.flush();

    // No morphing of the result columns required.

    // Print the result columns.
    //X_96->print(std::cout);

    // Free all intermediate results.
#ifdef MSV_NO_SELFMANAGED_MEMORY
    DataObjectFactory::destroy(X_47, X_53, X_77, X_81, X_93);
#endif

    std::cerr << "done." << std::endl;

    return 0;

    // ------------------------------------------------------------------------
    // Automatic analysis of the translated program
    // ------------------------------------------------------------------------

    //         Intermediates used before assigned
    // [good]: Found none.
    //
    //         Intermediates never used
    // [good]: Found none.
}
